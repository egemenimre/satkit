# Working with Orbital Elements

## Introduction to Keplerian Orbital Elements

Perhaps the most well-known representation of the orbit is the Classical or Keplerian Elements. These elements are based on 6 parameters (conic geometry and its orientation in space) and are equivalent to the 6 element cartesian coordinates (position and velocity).

A long and detailed definition is well beyond the scope of this documentation. More information can be found in [Wikipedia](https://en.wikipedia.org/wiki/Orbital_elements).

However, it must be noted that, these elements have singularities and ill-defined parameters for some special but common cases (such as true anomaly and argument of periapsis when the orbit is equatorial), and the implementation generally handles them gracefully. That said, parabolic orbits (eccentricity = 1.0) cannot be handled.

## Mean vs Osculating Elements

A not very obvious fact to those learning about the Keplerian Orbital Elements is that it is just a format to represent the orbit; without further definition, it is not very useful. This is similar to cartesian coordinates needing a coordinate system definition to actually represent a position in space.

The actual implementation of the Keplerian Elements rests on the force model under which they are generated. For example, the two-line element sets (TLEs) are Mean Keplerian Orbital Elements generated with a specific theory that includes linearised J2, J3 and J4 zonal harmonics and the elements are defined in True Equator, Mean Equinox coordinate frame. They would be incompatible with other Mean Elements generated with other force models and theories. Osculating Keplerian Orbital Elements are generated with a two-body force model.

Therefore, over a trajectory generated with a two-body force model, the Osculating Keplerian Orbital Elements (apart from true anomaly) should stay constant, limited by the accuracy of the trajectory generation algorithm. On the other hand, osculating orbital elements should be used with care, particularly in contexts where instantaneous orbital elements are computed on a trajectory generated by a non-two-body model (e.g. including geopotentials). The orbital elements will *not* stay constant along the trajectory, simply because the force model over successive points are not strictly two-body.

## Utilities to Compute Orbit Related Parameters

The {py:class}`.OrbitUtils` class contains some useful conversions and extra parameter computations.

The first one, {py:meth}`.OrbitUtils.compute_sma` converts the mean motion into semimajor axis. The input can be given as a `Quantity` object with units (for example in "radians per second” or “degrees per minute") or without units (reverting to the default “radians per second"). The output is always a `Quantity` object with units. The reverse method {py:meth}`.OrbitUtils.compute_mean_mot` takes in a semimajor axis (with units or defaulting to "metres") and outputs the mean motion value with units.

The {py:meth}`.OrbitUtils.compute_raan_drift_rate` is a more complex computation, taking mean semimajor axis, eccentricity and inclination as inputs, and outputting the drift of the Right Ascension of the Ascending Node (or, more generally, the drift of the orbital plane), with $J_2$ only or with additional $J_4$ and $J^2_2$ terms for higher precision. This enables the user to check the current orbit drift rates of orbits, particularly if the satellite is supposed to be on a special orbit like Molniya or Sun-Synchronous.

# Representing Orbits with Two-Line Elements (TLEs)

## Introduction to TLEs

A two-line element set (TLE) is a data format containing a set of TEME (True Equator, Mean Equinox) mean orbital elements of an Earth-orbiting object for a given point in time, called the Epoch Time.

These orbital elements are solely for use with the SGP4 propagator as the two are coupled with the underlying analytical orbit theory. [[OM1]](../../references.md#orbital-mechanics)

See the [TLE page in Wikipedia](https://en.wikipedia.org/wiki/Two-line_element_set) or [Space-Track definition](https://www.space-track.org/documentation#tle) for more information.

An example TLE is given as:

    ISS (ZARYA)
    1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927
    2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537

A TLE object is usually initialised from these two lines of strings:

    >>> line1 = "1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927"
    >>> line2 = "2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537"
    >>> tle = TLE(line1, line2)

## Components of a TLE

A TLE contains the well-known mean classical (or Keplerian) orbital elements such as Mean Anomaly, Right Ascension of the Ascending Node or Argument of Perigee. A semimajor axis is not directly defined, but the mean motion term given in revolutions/day can be used to derive the semimajor axis in a straightforward fashion. For example, a mean motion of 14.5 revolutions/day is equivalent to an orbital period of 5958.62 seconds, or a mean motion ($n$) of 0.00106 radians/second. Then the usual semimajor axis ($a$) can be derived from $a^3 n^2=\mu$, where $\mu$ is equal to the Gravitational Constant ($G$) times the mass of the Earth ($M$). In this example, the semimajor axis is equal to 7079.056 km.

In addition to the usual classical orbital elements, other components of the TLE are (adapted from the [Space-Track definition](https://www.space-track.org/documentation#tle)):

* Satellite catalog number (NORAD ID): The unique string representation of the object in space, assigned by USSTRATCOM. For example, the input integer of `25544` means ISS ZARYA module

* International Designator (COSPAR ID or NSSDCA ID): The unique string representation of the object in space. The field in the TLE `98067A` means 1998-067A, which means the Object A belonging to the 67th launch in the year 1998.

* Ballistic Coefficient: Also called the first derivative of mean motion, this is the daily rate of change in the number of revs the object completes each day, divided by 2. Units are revs/day. This is “catch all” drag term used in the Simplified General Perturbations (SGP4) USSPACECOM predictor.

* Second Derivative of Mean Motion: The second derivative of mean motion is a second order drag term in the SGP4 propagator used to model terminal orbit decay. It measures the second time derivative in daily mean motion, divided by 6. Units are $revs/day^3$.

* Drag Term (BSTAR): Also called the radiation pressure coefficient, the parameter is another drag term in the SGP4 predictor. Units are $1/earth radii$.

## Initialising the TLEs

While a TLE can be initialised using the regular Orekit `TLE` constructor by specifying the large number of initial parameters, by far the most usual way is to use initialise it with the regular two line input from an external source (see [Introduction to TLEs Section](#introduction-to-tles) for an example). Some external sources to retrieve TLEs are listed in [TLE Repositories Section](#common-tle-repositories).

Another way to initialise a TLE is by orbit type. For example, initialising a geostationary satellite TLE is as easy as defining a reference time and a target longitude:

    >>> tle_geo = TleFactory.init_geo(AbsoluteDateExt("2020-06-10T12:13:14.000", TimeScalesFactory.getUTC()), 42 * u.deg)
    >>> print(tle_GEO)
    1 99999U 12345A   20162.50918981  .00000000  00000-0  00000+0 0    15
    2 99999   0.0000 124.6202 0000000   0.0000   0.0000  1.00273791    04

Similarly, a circular sun-synchronous orbit at 800 km reference altitude (at Equator) and at a Local Time of the Ascending Node (LTAN) at 10:30 can be initialised simply with:

    >>> alt = 800 * u. km
    >>> ltan = 10.5
    >>> tle_sso = TleFactory.init_sso(AbsoluteDateExt("2020-06-10T12:13:14.000", TimeScalesFactory.getUTC()), alt, ltan)
    >>> print(tle_sso)
    1 99999U 00001A   20162.50918981  .00000000  00000-0  00000-0 0    12
    2 99999  98.6156  56.8074 0000000   0.0000   0.0000 14.27529684    00

Other parameters such as eccentricity, argument of perigee or mean anomaly as well as satellite-specific data such as International Designator or number of revolutions can be optionally set to initialise with the requested values. Note that, inclination cannot be set as it is a function of the semimajor axis and eccentricity.

## Common TLE Repositories

* Space-Track: <https://www.space-track.org/>

* Celestrak: <http://celestrak.com/NORAD/elements/>

* Heavens Above: <https://heavens-above.com>

# Other Orbit Utilities

## Ephemeris Propagator Generator

The `Ephemeris` propagator in Orekit is a propagator that takes in a series of discrete position-velocity-time combinations and stores them to generate interpolated internal outputs, just like any other propagator. On the other hand, the certain objects (notably Celestial Bodies) are only given as an object with a `PVCoordinatesProvider`. These objects can provide their own positions like a propagator, but it is not possible to have more advanced propagator functionalities (like an `EventsLogger`). To be able to convert such an `PVCoordinatesProvider`, we have to generate discrete trajectories and generate an `Ephemeris` propagator. The {py:meth}`.generate_ephemeris_prop` method does just that, generates discrete coordinates at a stepsize and an interpolation order. An example that generates the Sun coordinates at 600 second intervals within a certain propagation interval (`prop_interval`) is given below:

```
stepsize = 600.0  # seconds

# shorthand for UTC
utc = TimeScalesFactory.getUTC()

# generate Sun as a PVCoordinatesProvider
sun_coords = PVCoordinatesProvider.cast_(CelestialBodyFactory.getSun())

prop_interval = TimeInterval(
    AbsoluteDateExt("2014-01-01T23:30:00.000", utc),
    AbsoluteDateExt("2014-01-01T23:35:00.000", utc),
)

generate_ephemeris_prop(prop_interval, sun_coords, stepsize=stepsize)
```